兼容性

**存储引擎架构**
将查询处理、系统任务和数据的存储/提取相分离
可以在使用时根据性能、特性以及其他需求来选择数据存储的方式

第一层：
	客户端：连接处理、授权认证、安全
第二层：
	查询解析、分析、优化、缓存以及所有内置函数
	所有跨存储引擎的功能都在这一层实现：存储过程、触发器、试图
第三层：
	存储引擎：负责MySql中数据的存储和提取。
	服务器通过API与存储引擎进行通信。接口屏蔽了不同存储引擎之间的差异。
	操作：开始一个事务、根据主键提取一行纪录等

ps：存储引擎不会去解析SQL，但Innodb是一个例外，它会解析外键定义，因为MySql服务器本身没有提供该功能


优化和执行：
解析查询，创建内部数据结构(解析树)，进行优化(重写查询、决定表的读取顺序、选择合适的索引)

并发控制：
	服务器层和存储引擎层
	读写锁
	锁粒度：在给定资源上，锁定的数据量越少，并发程度越高
			问题是加锁也需要消耗资源，锁的各种操作(获得、检查、释放)都会增加系统开销
	锁策略：在锁的开销和数据的安全性之间寻求平衡
	每个存储引擎都可以实现自己的锁策略和锁粒度

	表锁：
		表锁是开销最小的锁，锁定整张表。
		特定的场景，表锁也有可能有良好的性能。ps：READ LOCAL表锁支持某些类型的并发操作。
		写锁比读锁有更高的优先级

		尽管存储引擎可以自己管理自己的锁，服务器还是会使用各种有效的表锁来实现不同的目的，ps：服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制

	行级锁：
		可以最大程度的实现并发处理(同时带来最大的锁开销),ps：InnoDB和XtraDB等。
		只在存储引擎中实现行级锁，服务器层完全不了解存储引擎的锁实现

事务：
	事务就是一组原子性的SQL查询
	ACID：
		原子性：
			一个事务要不全部提交成功，要不全部失败回滚
		一致性：
			数据库总是从一个一致性状态转换到另外一个一致性状态。
		隔离性：
			一个事务所做的修改在最终提交之前，对其他事务是不可见的
		持久性：
			一旦事务提交，则其所做的修改在最终提交之前，对其他事务是不可见的

	隔离级别：
		每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。

		未提交读：
			事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，发生脏读。
		提交读：
			一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的
			大多数数据库系统默认的隔离级别。
		可重复读：
			解决了脏读问题，但是会产生幻读，InnoDB和XtraDB通过多版本并发控制(MVCC)解决幻读的问题，这也是MySql的默认事务隔离级别
		可串行化：
			强制事务串行执行，避免了幻读问题

死锁：
	InnoDB处理方法：将持有最少行级排他锁的事务进行回滚
	死锁的产生 {
		1.真正的数据冲突：很难避免
		2.存储引擎的实现方式导致的
	}

事务日志：
	使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到日志中，而不需要每次都将修改的数据本身持久到磁盘

	MySql提供了两种事务型的存储引擎，InnoDB和NDB Cluster。还有些第三方，比如XtraDB和PBXT

	InnoDB的MVCC(多版本并发控制)：
		通过在每行记录后面保存两个隐藏的列来实现的，一个保存了行的创建时间，一个保存过期时间，存储的并不是实际的时间，而是系统版本号(每开始一个新的事务，系统版本号自动递增)

InnoDB：
	1.数据存储在表空间，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成
	2.可以将每个表的数据和索引存放在单独的文件中
	3.采用MVCC来支持高并发，默认级别是可重复读
	4.通过间隙锁策略防止幻读的出现
	(不仅仅锁定查询所涉及的行，还会对索引中的间隙进行锁定)
	5.InnoDB表基于聚簇索引建立
		对主键查询有很高的性能，不过它的二级索引中必须包含主键列，如果主键列很大的话，其他所有索引都会很大。
	6.InnoDB的存储格式是平台独立的
	7.内部优化：
		从磁盘读取数据时采用的可预测性预读，能自动在内存中创建hash索引以加速读操作的自适应哈希索引。
		加速插入操作的插入缓冲区
	8.支持热备份，获取一致性视图需要停止对所有表的写入，读写混合的场景，停止写入可能意味着停止读取

MyISAM：
	1.提供大量的特性：全文索引、压缩、空间函数(GIS)等
	2.不支持事务和行级锁
	3.崩溃后无法安全恢复
	4.将表存储在两个文件中：数据文件和索引文件
	5.可以包含动态或者静态行
	6.加锁与并发：
		对整张表加锁，读取时需要对读到的所有表加共享锁，写入时则对表加排他锁。
		但是在表有读取查询的同时，也可以往表中插入新的记录(并发插入)
	7.支持全文索引，这是一种分词创建的索引，可以支持复杂的查询
	8.支持延迟更新索引键：通过内存中的键缓冲区实现，只有在清理缓冲区或者关闭表时才会将对应的索引块写入磁盘
	9.支持压缩表，压缩表不能进行修改，可以极大减少磁盘空间占用，减少IO，提升查询性能，压缩表也支持索引，索引也是只读的。
		记录独立压缩，读取单行时不需要去解压整个表(甚至不用解压行所在的整个页面)
	

