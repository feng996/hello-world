公共问题 {
	磁盘读写
}

Innodb {
	Innodb是MySql默认事务性引擎，被设计用来处理大量的短期事务(短期事务大部分是正常提交的，很少被回滚)
	Innodb的性能和自动崩溃恢复的特性，使得他非常流行
	Innodb数据存储在表空间，表空间是由Innodb管理的一个黑盒子，由一系列文件组成
	Innodb采用MVCC来支持高并发，并实现了四个标准的隔离级别(未提交读、提交读、可重复读、串行化)
	Innodb是基于聚簇索引建立的
}

Innodb是如何防止幻读的：通过间隙锁（间隙锁使得Innodb不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入）

什么是聚簇索引 {
	聚簇索引并不是一种单独的索引类型，而是一种存储方式，实际上是在同一个结构中保存了索引和数据行
	数据行实际上存放在索引的叶子页中
}

什么是存储过程 {
	存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合
	调用存储过程可以减少数据在数据库和应用服务器之间的传输

	存储过程和函数的区别：函数必须有返回值，而存储过程没有

	delimiter $$
	create procedure film_in_stock (in p_film_id int, in p_store_id int, out p_film_count int)
	reads sql data
	begin 
		select inventory_id
		from inventory
		where film_id = p_film_id
		and store_id = p_store_id
		and inventory_in_store(inventory_id)

		select found_rows() into p_film_count;

	end $$

	dlimiter ;

	具体需要补
}

说一下触发器 {
	触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合

	trigger
}

说一下事务控制 {
	事物控制就是自己管理事务的开始和结束，因为MySql时自动提交的

	分布式事物需要了解
}

SQL安全问题 {
	SQL注入 {
		利用某些数据库的外部接口将用户数据插入到实际的SQL当中
	}
}

说一下MySql分区 {
	分区是根据一定规则将表分解成多个更小的、更容易管理的部分。
	分区对于应用来说是透明的，不影响业务逻辑，逻辑上只有一个表

	优点 {
		可以存储更多的数据
		优化查询：在where子句中包含分区条件时，可以只扫描必要的分区，涉及sum或者count的时候可以分区并行处理
					，跨多个磁盘来分散查询，以获得更大的查询吞吐量
		优化删除：可以通过删除分区快速删除某些条件的数据
	}

	MySql不禁止在分区键值上使用NULL，它会把NULL当作零值或者最小值
}

SQL优化 {
	定位执行效率低的SQL语句 {
		通过慢查询日志，问题是慢查询日志在查询结束以后才记录
		show processlist {
			查看当前MySql在进行的线程(包括线程状态、是否锁表)，可以实时的查看sql的执行情况，同时对一些锁表进行优化
		}
	}

	通过explain分析低效的sql语句 {
		type {
			all(全表扫描)--index(索引全扫描)--range(索引范围扫描)--ref(非唯一或者唯一前缀)--eq_ref(唯一)
			const/system(单表中最多有一个匹配行)--null(不用访问表或者索引就能直接得到结果)
		}
	}

	show profile for query {
		可以看到执行过程中线程的每个状态和消耗时间
	}

	通过trace分析优化器如何选择执行计划

	索引优化 {
		b+树：平衡树，查找复杂度为logn  底数是分叉数
		最左匹配原则：即索引包含多列在使用的时候必须包含第一列，否则将不会被使用到该索引
	}
}