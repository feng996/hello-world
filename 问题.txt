公共问题 {
	磁盘读写
}

Innodb {
	Innodb是MySql默认事务性引擎，被设计用来处理大量的短期事务(短期事务大部分是正常提交的，很少被回滚)
	Innodb的性能和自动崩溃恢复的特性，使得他非常流行
	Innodb数据存储在表空间，表空间是由Innodb管理的一个黑盒子，由一系列文件组成
	Innodb采用MVCC来支持高并发，并实现了四个标准的隔离级别(未提交读、提交读、可重复读、串行化)
	Innodb是基于聚簇索引建立的
}

Innodb是如何防止幻读的：通过间隙锁（间隙锁使得Innodb不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入）

什么是聚簇索引 {
	聚簇索引并不是一种单独的索引类型，而是一种存储方式，实际上是在同一个结构中保存了索引和数据行
	数据行实际上存放在索引的叶子页中
}

什么是存储过程 {
	存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合
	调用存储过程可以减少数据在数据库和应用服务器之间的传输

	存储过程和函数的区别：函数必须有返回值，而存储过程没有

	delimiter $$
	create procedure film_in_stock (in p_film_id int, in p_store_id int, out p_film_count int)
	reads sql data
	begin 
		select inventory_id
		from inventory
		where film_id = p_film_id
		and store_id = p_store_id
		and inventory_in_store(inventory_id)

		select found_rows() into p_film_count;

	end $$

	dlimiter ;

	具体需要补
}

说一下触发器 {
	触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合

	trigger
}

说一下事务控制 {
	事物控制就是自己管理事务的开始和结束，因为MySql时自动提交的

	分布式事物需要了解
}

SQL安全问题 {
	SQL注入 {
		利用某些数据库的外部接口将用户数据插入到实际的SQL当中
	}
}

说一下MySql分区 {
	分区是根据一定规则将表分解成多个更小的、更容易管理的部分。
	分区对于应用来说是透明的，不影响业务逻辑，逻辑上只有一个表

	优点 {
		可以存储更多的数据
		优化查询：在where子句中包含分区条件时，可以只扫描必要的分区，涉及sum或者count的时候可以分区并行处理
					，跨多个磁盘来分散查询，以获得更大的查询吞吐量
		优化删除：可以通过删除分区快速删除某些条件的数据
	}

	MySql不禁止在分区键值上使用NULL，它会把NULL当作零值或者最小值
}

SQL优化 {
	定位执行效率低的SQL语句 {
		通过慢查询日志，问题是慢查询日志在查询结束以后才记录
		show processlist {
			查看当前MySql在进行的线程(包括线程状态、是否锁表)，可以实时的查看sql的执行情况，同时对一些锁表进行优化
		}
	}

	通过explain分析低效的sql语句 {
		type {
			all(全表扫描)--index(索引全扫描)--range(索引范围扫描)--ref(非唯一或者唯一前缀)--eq_ref(唯一)
			const/system(单表中最多有一个匹配行)--null(不用访问表或者索引就能直接得到结果)
		}
	}

	show profile for query {
		可以看到执行过程中线程的每个状态和消耗时间
	}

	通过trace分析优化器如何选择执行计划

	索引优化 {
		b+树：平衡树，查找复杂度为logn  底数是分叉数
		最左匹配原则：即索引包含多列在使用的时候必须包含第一列，否则将不会被使用到该索引
	}
}


面向对象和面向过程有什么区别 {
	面向对象 {
		它是把数据及数据的操作方法放在一起，作为一个相互依存的整体，即对象，对同类对象抽象出其共性，即类，类中的大多数数据，只能被本类的方法进行处理。类通过简单的外部接口与外界发生关系，对象和对象之间通过消息进行通信。程序流程由用户在使用中决定
	}

	面向过程 {
		面向过程是一种以事件为中心的开发方法，就是自顶向下执行，逐步求精，其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构，各模块之间的关系也比较简单，在功能上相对独立
	}

	不同点 {
		出发点不同 {
			面向对象是符合常规思维方式来处理客观世界问题
			面向过程是以过程为中心，强调过程的抽象化与模块化
		}

		层次逻辑关系不同 {
			面向对象是用类的层次结构来体现类之间的继承和发展
			面向过程是用模块的层次结构概括模块之间的关系与功能
		}

		数据处理方式与控制程序方式不同 {
			面向对象方法将数据与对应的代码封装成一个整体。原则上只能通过自身的函数完成，控制流程是以事件驱动来激活和运行程序

			面向过程是直接通过程序来处理数据，控制程序方式是按照设计调用或返回程序
		}

		分析设计与编码转换方式不同 {
			面向对象从分析到编码是采用一致性模型标识，即实现一种无缝连接
			面向过程强调分析、设计、编码按规则进行转换，是一种有缝的连接
		}
	}
}


Statement、PreparedStatement、CallableStatement有什么区别 {
	Statement用于执行不带参数的简单SQL语句，并返回它所生成的对象
	PreparedStatement表示预编译的SQL语句的对象，用于执行带参数的预编译SQL语句
	CallableStatement提供了用来调用数据库存储过程的接口
}

jdk Arrays.sort {
	

	基本数据类型排序 {
		优化的快速排序

		小规模(size<7)数组中，使用直接插入
		选择枢轴
	}

	对象数组排序 {
		经过修改的归并排序

		小规模直接插入排序
		低子列表最高元素小于高子列表最小元素，则忽略合并
	}
}

java编译过程 {
	解析与填充符号表 {
		词法分析 {
			源代码的字符转变为标记集合
		}
		语法分析 {
			根据Token序列构造抽象语法树
		}
		填充符号表 {
			符号表：由一组符号地址和符号信息构成的表格
			出口是一个待处理列表 {
				包含每一个编译单元的抽象语法树的顶级节点
			}
		}
	}

	注解处理器

	语义分析与字节码生成 {
		标注检查{
			变量使用前是否已经声明、变量与赋值之间的数据类型是否能够匹配
		}
		数据及控制流分析 {
			程序局部变量在使用前是否由赋值、方法的每条路径是否有返回值
		}

		字节码生成
	}
}

java stream {
	Stream 是对集合对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作,或者大批量数据操作
	Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势
}


java NIO {
	NIO是一种同步非阻塞的I/O模型

	NIO利用事件模型处理I/O，解决线程池瓶颈处理海量连接

	传统的同步阻塞I/O处理 {
		因为accept、read、write三个函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里，但是CPU被释放出来，开启多线程就能让CPU去处理更多的事情

		现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低

		不过，这个模型的问题在于严重依赖于线程，但是线程是很贵的资源，线程的创建和销毁成本很高，在Linux上，线程本质就是一个进程
	}
}

在浏览器输入一个url后，hui进行哪些技术步骤 {
	1.浏览器对用户输入的网址做初步格式化检查
	2.默认使用http协议
	3.DNS查询IP地址 {
		如果缓存没有，就需要访问DNS服务器
		1.UDP
		2.查询IP路由表
		3.如果没有则ARP协议查看MAC地址
		4.返回IP地址
	}
	4.TCP协议传送http请求的消息

	5.TLS进行认证加密算法等
}


java 锁 {
	偏向锁 {
		当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁

		偏向锁获取过程：
		1.访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
		2.如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。
		3.如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。
		4.如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）
		5.执行同步代码。

	}

	轻量级锁 {
		加锁 {
			JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针，如果成功，则获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获得锁。
		}

		解锁 {
			使用CAS将Mark Word替换回到对象头，如果成功，则没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
		}
	}
}



hashmap {
	jdk 1.7 {
		Entry<K,V> next = e.next;
        if (rehash) {
            e.hash = null == e.key ? 0 : hash(e.key);
        }
        int i = indexFor(e.hash, newCapacity);
        e.next = newTable[i];
        newTable[i] = e;
        e = next;
	}
}

java 线程池 {
	线程池判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务

	线程池判断工作队列是否已经满了，如果工作队列没有满，则将新提交的任务存储在工作队列里

	线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的线程来执行任务。如果满了则交给饱和策略来处理这个任务


	创建 {
		new ThreadPoolExecutor

		corePoolSize: 线程池基本大小，prestartAllCoreThreads提前创建并祁东所有基本线程

		runnableTaskQueue:任务队列，用于保存等待任务的阻塞队列 {
			ArrayBlockingQueue:基于数组结构的有界阻塞队列，FIFO
			
			LinkedBlockingQueue:基于链表结构的阻塞队列，FIFO，静态工厂方法Executors.newFixedThreadPool()使用了这个队列

			SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则阻塞，静态工厂方法Executors.newCachedThreadPool使用了这个队列

			PriorityBlockingQueue:一个具有优先级的无限阻塞队列
		}

		maximumPoolSize:线程池最大数量

		ThreadFactory:用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字

		RejectedExecutionHandler:饱和策略 {
			AbortPolicy:直接抛出异常，默认
			CallerRunsPolicy:只用调用者所在线程来运行任务
			DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务
			DiscardPolicy:不处理，直接丢弃
		}
	}

	关闭线程池 {
		逐个调用线程的interrup来中断线程
		shutdown {
			将线程池的状态设置成SHUTDOWN，然后中断所有没有正在执行任务的线程
		}

		shutdownNow {
			首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停的任务
		}

		调用了这两个方法，isShutdown方法就会返回true，当所有任务都已关闭后，才表示线程池成功关闭，这是isTerminaed方法会返回true
	}

	使用 {
		CPU密集：少的线程
		IO密集：多的线程
	}

	监控 {
		taskCount:线程池需要执行的任务数量
		completedTaskCount:线程池在运行过程中已完成的任务数量
		largestPoolSize:线程池曾经创建过的最大线程数量
		getPoolSize:线程池的线程数量
		getActiveCount:获取活动的线程数
	}
}