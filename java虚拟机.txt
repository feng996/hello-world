 
Java虚拟机 {
	运行时数据区 {
		由所有线程共享的数据区 {
			方法区 {
				存储已被虚拟机加载的类信息、常量和静态变量、即时编译器编译后的代码等数据

				运行时常量池 {
					存放编译期生成的各种字面量和符号引用(将在类加载后进入方法区的运行时常量池中存放)
					除了符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中
				}
			}

			堆 {
				堆是被所有线程共享的一块内存区域，在虚拟机启动时创建
				该区域存放对象实例

				垃圾收集器(GC)管理的主要区域

				由于现在收集器基本采用分代收集算法，所以堆分为新生代和老年代

				java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可
			}
		}

		线程隔离的数据区 {
			虚拟机栈 {
				生命周期和线程相同

				描述java方法执行的内存模型 {
					每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息

					每个方法从调用到完成的过程，就对应着一个栈帧在虚拟机栈中的入栈和出栈

					局部变量表 {
						存放编译期可知的各种基本数据类型、对象引用类型和returnAddress类型

						64位的double和long占用两个局部变量空间

						局部变量表所需的内存在编译期间完成分配
					}
				}
			}

			本地方法栈 {
				与虚拟机栈相似，只不过是执行native方法
			}

			程序计数器 {
				当前线程所执行的字节码的行号指示器

				字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
				为了线程切换后能恢复到正确的执行位置，每条线程都需要由一个独立的程序计数器

				如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码指令的地址
				如果执行的是一个native方法，则计数器值为空

				此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
			}
		}
	}

	直接内存 {
		NIO类 {
			引入一种基于通道与缓冲区的I/O方式
			可以使用native函数库直接分配堆外内存，然后通过存储在java堆中的directbytebuffer对象作为这块内存的引用进行操作
			避免了在java堆和native堆上来回复制数据
		}
	}


	对象的创建 {
		new --> 检查这个指令的参数是否能在常量池中定位到一个类的符号引用 -->
		检查这个符号引用代表的类是否已经被加载、解析或者初始化过(没有则需先执行相应的类加载过程) -->
		虚拟机将为新生对象分配内存(对象所需内存大小在类加载完成后便可完全确定) -->
		虚拟机需要将分配到的内存空间都初始化为零值 -->
		对对象进行必要的设置(哪个类的实例、哈希码、分代) -->
		执行init，按照程序员的意愿进行初始化
	}

	对象内存布局 {
		对象头 {
			存储自身运行时数据
			类型指针(指向它的类元数据的指针)

			如果是数组，对象头还有一块用于记录数组长度的数据
		}

		实例数据 {
			存储有效信息

			父类定义的变量会出现在子类之前
		}

		对齐填充 {
			起占位符作用
			hotspot要求对象起始地址必须是8字节的整数倍
		}
	}

	对象的访问定位 {
		句柄访问 {
			句柄包含对象实例数据与类型数据各自具体的地址信息
		}

		直接指针访问 {
			reference存储的直接就是对象地址
		}

		句柄访问好处就是reference中存储的稳定的句柄地址，对象被移动时指挥改变句柄中的实例数据指针

		直接指针访问好处就是速度更快，节省了一次指针定位的时间开销
	}

	垃圾回收 {
		引用计数算法 {
			给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1，引用失效就减1，任何时候计数器为0的对象就是不可能再被使用的

			问题：对象之间相互循环引用的问题
		}

		可达性分析算法 {
			通过一系列的称为"GC root"的对象作为起始点，从这些节点开始往下搜索，搜索走过的路径称为引用链，当一个对象到GC roots没有任何引用链相连时，则证明该对象是不可用的

			gc roots {
				虚拟机栈中引用的对象
				方法区中类静态属性引用的对象
				方法区中常量引用的对象
				本地方法栈中Native方法引用的对象
			}
		}

		无用的类 {
			该类所有的实例都已经回收，java堆中不存在该类的实例
			加载该类的ClassLoader已经被回收
			该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
		}

		标记-清除算法 {
			首先标记出所有需要回收的对象，标记完成后统一回收

			缺点 {
				效率问题:标记和清楚效率都不高
				空间问题:标记清除后会产生大量不连续的碎片
			}
		}

		复制算法 {
			将可用内存按容量划分为大小相等的两块，每次只使用一块，当一块内存用完了，就将还活着的对象复制到另一块上，然后把已使用过的内存空间一次性清理掉
		}

		标记-整理算法 {
			标记后不直接清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界之外的内存
		}

		分代收集算法 {
			新生代:复制算法
			老年代:标记-清理或标记-整理
		}

		中断方式 {
			抢占式中断 {
				首先把所有线程全部中断，如果发现有线程没有在安全点上，就恢复线程，让他跑到安全点上
			}
			主动式中断 {
				当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起
			}
		}
	}
}