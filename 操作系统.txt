进程 {
	程序段
	数据段
	PCB {
		记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息

		信息 {
			进程标识符
			处理机状态{
				处理机的上下文，主要是由处理机的各种寄存器中的内容组成
			}
			进程调度信息
			进程控制信息
		}

		作用 {
			作为独立运行基本单位的标志
			能实现间断性运行方式
			提供进程管理所需要的信息
			提供进程调度所需要的信息
			实现与其他进程的同步和通信
		}
	}

	定义 {
		进程是程序的一次执行
		进程是一个程序及其数据在处理机上顺序执行时所发生的活动
		进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的基本单位

		进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位
	}

	特性 {
		动态性：进程实体具有一定的生命周期
		并发性：多个进程实体同时存在于内存中，且能在一段时间内同时运行
		独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位
		异步性：进程是按异步的方式运行的，即按各自独立的、不可预知的速度向前推进
	}
}

进程控制 {
	os内核 {
		与硬件紧密相关的模块(中断处理程序)
		各种常用设备的驱动程序以及运行频率较高的模块(时钟管理、进程调度)

		功能 {
			支撑功能 {
				提供给os其他众多模块所需要的一些基本命令

				中断处理 {
					系统调用、键盘命令、进程调度、设备驱动等都依赖中断处理
				}
				时钟管理 {
					截至时间控制、批处理系统的最长运行时间控制
				}
				原语操作 {
					不可分割的基本单位，原语在执行过程中不允许被中断
				}
			}

			资源管理功能 {
				进程管理：进程的同步原语、常用进程通信原语等
				存储器管理：地址转换机构、内存分配和回收等
				设备管理：各类设备的驱动程序、缓冲管理
			}
		}
	}
}

进程的创建和终止 {
	调用进程创建原语Creat {
		1.申请空白PCB，为新进程申请获得唯一的数字标识符，从PCB集合获取空白PCB
		2.为新进程分配其运行所需的资源，包括各种物理和逻辑资源(内存、文件、I/O、设备和CPU时间)，从操作系统或父进程获得
		3.初始化PCB {
			初始化标识信息(系统分配的标识符和父进程标识符填入PCB中)
			初始化处理机状态信息(程序计数器指向程序的入口地址)
			初始化处理机控制信息(进程状态和优先级)
		}
	}

	调用终止原语 {
		根据标识符，从PCB集合中检索出该进程的PCB，从中读出状态
		若进程处于执行状态，应立即终止该进程及其子孙进程执行，并将调度标志为真
		将其所拥有的全部资源归还给其父进程，或者归还给系统
		将进程从所在队列中移除
	}
}

进程阻塞与唤醒 {
	引起进程阻塞和唤醒的事件 {
		向系统请求共享资源失败
		等待某种操作的完成
		新数据尚未到达
		等待新任务的到达
	}
}

同步机制应遵守的规则 {
	空闲让进、忙则等待、有限等待、让权等待
}

进程之间的两种基本关系 {
	间接相互制约 {
		CPU、I/O设备等，对于这样的临界资源，必须保证进程对之互斥的访问
	}

	直接相互制约 {
		为了完成某种任务而建立了两个或多个进程，这些进程为完成同一项任务而相互合作
	}
}

进程通信类型 {
	共享存储器系统 {
		相互通信的进程共享某些数据结构或共享存储区
	}

	管道通信系统 {
		管道是指连接一个读进程和一个写进程以实现它们之间通信的一个共享文件

		三个协调能力 {
			互斥：每次只有一个进程可以进行读写
			同步：完成操作后需要等待另外一个进程的唤醒
			确认对方是否存在
		}
	}

	消息传递系统 {
		进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间传递消息，完成数据交换

		直接通信方式：通过os提供的发送原语，直接把消息发送给目标进程

		间接通信方式：通过共享中间实体进行消息的发送和接收 {
			信箱通信 {
				信箱头：存放有关信箱的描述信息(信箱标识符、拥有者、口令)
				信箱体：若干个可以存放消息的信箱格组成
			}
		}
	}

	客户机-服务器系统 {
		套接字 {
			文件型：一个套接字关联到一个特殊的文件，类似管道
			网络型
		}

		远程过程调用和远程方法调用 {
			RPC：是一个通信协议，该协议允许一台主机系统上的进程调用另一台主机系统上的进程，而对程序员表现为常规的过程调用

			存根：在本地客户端每个能够独立运行的远程过程都拥有一个客户存根
		}
	}
}


进程引入目的：为了使多个程序能并发执行，以提高资源利用率和系统吞吐量
线程引入目的：减少程序在并发执行时所付出的时空开销，使os具有更好的并发性

进程的两个属性 {
	可拥有资源的独立单位
	可独立运行和分派的基本单位
}

线程 {
	将进程的两个属性分开，由os分开处理，对于拥有资源的单位，不进行频繁的切换

	调度和分派的基本单位
}

线程和进程的比较 {
	线程较传统进程比较，线程拥有许多传统进程所具有的特征，所以称为轻型进程

	调度性 {
		传统的os中，进程切换需要进行上下文切换，开销较大
		线程切换仅需要保存和设置少量寄存器内容，切换代价远低于进程
	}

	并发行 {
		在引入线程的操作系统中，不同进程可以并发执行，进程中的多个线程也可以并发执行，不同进程中的线程也可以并发执行，使得os具有更好的并发性，从而能更有效的提高系统资源的利用率和系统的吞吐量
	}

	拥有资源 {
		进程可以拥有资源，并作为系统中拥有资源的基本单位，线程本身不拥有系统资源，仅有一点必不可少的、能保证独立运行的资源。

		线程除了拥有自己的少量资源外，还允许多个线程共享进程所拥有的资源，表现在属于统一进程的所有线程都具有相同的地址空间并可以访问进程所拥有的资源。
	}

	独立性 {
		同一进程中的不同线程之间的独立性要比不同进程之间的独立性要低得多
	}

	系统开销 {
		创建、撤销或切换进程时的开销远远大于线程
	}

	支持多处理机系统 {
		一个进程只能运行在一个处理机上，对于多线程进程，可以将一个进程中的多个线程分配到不同的处理机上
	}
}


处理机调度 {
	高级调度(作业调度) {
		调度对象是作业，功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存
	}

	低级调度(进程调度) {
		调度对象是进程，功能是根据某种算法决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给选中的进程
	}

	中级调度(内存调度) {
		引入中级调度的主要目的是，提高内存利用率和系统吞吐量。
		将那些暂时不能运行的进程，调至外村等待，此时进程的状态就是挂起状态
	}
}

作业运行的三个阶段和状态 {
	作业从进入系统到运行结束，经历收容、运行、完成三个阶段，相应的就有后备状态、运行状态、完成状态

	收容阶段：操作员把用户提交的作业通过某种输入方式输入到硬盘上，再为该作业建立JCB，并放入作业后备队列中

	运行阶段：当作业被作业调度选中后，便为它分配必要的资源和建立进程，并放入就绪队列

	完成状态：作业运行完成，系统"终止作业"程序会回收已分配给该作业的作业控制块和资源，并将作业运行结果信息形成输出文件后输出
}

作业调度算法 {
	先来先服务(FCFS)
	短作业优先(SJF)
	优先级调度算法(PSA)
	高相应比算法(HRRN) {
		优先权 = 等待时间 + 要求服务时间 / 要求服务时间 = 响应时间 / 要求服务时间
	}
}

进程调度 {
	进程调度任务 {
		保存处理机的现场信息
		按某种算法选取进程
		把处理器分配给进程
	}

	进程调度方式 {
		非抢占方式
		抢占方式 {
			优先权原则：优先级高的先获得处理机
			短进程有限原则：段进程优先获得处理机
			时间片原则：各进程按时间片轮转运行
		}

		轮转调度算法
		优先级调度算法 {
			抢占式：只要出现优先级高的就切换

			静态优先级和动态优先级
		}
		多队列调度算法 {
			将系统中的进程就绪队列从一个拆分成多个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法

			多处理机系统中，由于安排了多个就绪队列，可以很方便为每个处理机设置一个单独的就绪队列
		}

		多级反馈队列调度算法 {
			调度机制 {
				设置多个就绪队列，并为每个队列赋予不同的优先级(梯度递减)
				优先级越高的队列，其时间片就越少
				每个队列采用FCFS
			}
		}

		保证调度算法 {
			跟踪计算每个进程自创建以来已经执行的时间
		}

		公平分享调度算法 {
			根据用户分配
		}

		最早截止时间优先算法EDF
		最低松弛度优先算法LLF {
			根据任务的紧急程度，赋予更高的优先级
		}
	}
}

死锁 {
	在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源

	原因 {
		竞争不可抢占性资源
		竞争可消耗资源
		进程推进顺序不当
	}

	必要条件 {
		互斥：在一段时间内，某资源只能被一个进程占用
		请求和保持：进程已经保持了至少一个资源，但又申请新的资源
		不可抢占条件：进程已获得的资源在未使用完之前不能被抢占
		循环等待条件
	}

	处理死锁的方法 {
		预防死锁：通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个
		避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，比如银行家算法
		检测死锁：通过检测机构及时的检测出死锁的发生
		解除死锁：采取适当的措施，把进程从死锁中解脱出来
	}
}

基于顺序搜索的动态分区 {
	首次适应算法FF
	循环首次适应NF
	最佳适应算法BF
	最坏适应算法WF
}

基于索引搜索的动态分区 {
	快速适应算法(分类搜索法)
	伙伴系统
	哈希算法
}

分页、分段、段页

页面置换算法 {
	最佳置换算法
	先进先出FIFO
	最近最久未使用LRU
	最少使用LFU
}